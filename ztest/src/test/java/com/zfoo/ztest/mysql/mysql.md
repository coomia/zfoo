#基础概念

##一、范式
- 第一范式（1NF）
```
在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 
所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。
如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。
简而言之，第一范式就是无重复的列。
```

- 第二范式（2NF）
```
第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。
第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。 
第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，
如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。
简而言之，第二范式就是非主属性非部分依赖于主关键字。
```

- 第三范式（3NF）
```
满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。
例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。
那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。
如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。
简而言之，第三范式就是属性不依赖于其它非主属性。（我的理解是消除冗余）
```

##二、数据库引擎
- MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对较小，对事务完整性没有要求，以select、insert为主的应用基本上可以使用这引擎
- Innodb:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键约束，并发能力强，占用空间是MYISAM的2.5倍，处理效率相对会差一些
- Memory:全表锁，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在mysql重启时会丢失，默认使用HASH索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变化不频繁的代码表
- MERGE：是一组MYISAM表的组合


##三、分表方法
- 在数据库使用过程中，为了减小数据库服务器的负担、缩短查询时间，会考虑做分表设计
```
分表分为两种：一种是纵向分表（将本来可以在同一个表的内容，认为划分存储为多个不同结构的表）和横向分表（把大的表结构，横向切割为同样结构的不同表）
```

###1. 纵向分表
常见的分表方式：根据活跃度、重要性分表，主要解决如下问题：
```
表与表之间的资源争用问题
锁争用几率小
实现核心与非核心的分级存储
解决数据库同步压力问题
```

###2. 横向分表
根据某些特定规则来划分数据量表，主要解决如下问题：
```
单表过大造成的性能问题
单表过大造成的单服务器空间问题
```

#sql语句

##一、连接
1. 左连接：left join，如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值(null)
2. 右连接：right join，如果右表的某行在左表中没有匹配行，则将为左表返回空值
3. 内连接（inner join），如果表中任意一条数据在另一张表中都是找不到对应数据的话，那么在结果表中是不会有这一条数据的。
4. 外链接（outer join），如果某张表中的数据在另一张中找不到对应的条目并不影响它依然出现在查询的结果中，这就有一点数学里的并集的意思

##二、sql语句慢
```
从出现的概率由大到小如下：
    SQL编写问题
    锁
    业务实例相互干扰对IO/CPU资源的竞争
    服务器硬件
    MYSQL BUG
```

##三、sql优化
```
字段类型转换导致不用索引，如字符串类型不用引号，数字类型用引号等
mysql 不支持函数转换，字段面前不能加函数
不要在字段面前加减运算
字符串比较长的可以考虑索引一部分减少索引文件的大小，提高写入效率
like %在前面用不到索引，需要写在检索关键字的后面
根据联合索引的第二个及以后的字段单独查询用不到索引
不要使用select *
排序尽量使用升序
or的查询尽快用union代替
复合索引高选择性的字段排在前面
order by/group by 字段包括在索引当中减少排序，效率会更高
删除表所有记录用truncate,不要用delete
不要让mysql干多余的事情，例如计算
```

#事务

##一、事务的隔离级别
```
更新丢失:当两个或多个事务选择同一行，然后基于最初的值选定该行进行更新该行时，由于事务之间没有联系，就会发生丢失更新的问题，
    如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一个文件，就可以避免这类问题
    
脏读：一个事务在对一条数据进行修改，在事务完成并提交前，记录就处于不一致的状态，这是另外一个事务也来读取同一条记录，
    如果不加以控制，第二个事务读取了这些“脏”数据，并据此做进一步处理，就会产生未提交数据的依关系
    
不可重复读:一个事务在读取某些数据后的某个时间在，再次读取的时候，发现数据发生改变，或者某些记录被删除了

幻读:一个事务按相同的查询条件重复读取以前检索过的数据，却发现了其它事务插入了满足其查询条件的新数据


隔离级别	                            读取数据一致性	        脏读	  不可重复读	   幻读
未提交读(Read uncommitted)	最低级别，只能保证读取不损坏数据	是	    是	        是
已提交读（Read committed）	        语句级	                否	    是	        是
可重复读（Repeatable read）	        事务级	                否	    否	        是
可序列化（Serializable）	            最高级别，事务级	        否	    否	        否
```

##二、四个特性
- 四个基本要素（acid）：原子性、一致性、隔离性、持久性
1. 原子性(Actomicity)：整个事务中的操作要么全完成，要么全部不完成，不能滞留在中间某个环节，事务在执行过程发生错误，会被回滚（Rollback）到事务开始前的状态，就像没执行过一样
2. 一致性(Consistent)：在事务开始和结束之后，数据库的完整性约束没有被破坏
3. 隔离性(Isolation):使事务在给定的时间内执行的唯一操作，为了防止事务之间的混淆，必须串行化或序列化请求，使得在同一时间内仅有一个请求用于同一数据
4. 持久性(Durable):在事务完成以后，该事务所对数据库所做的更改持久保存到数据库之中，并不会被回滚

##三、锁
1. 表级锁：每次操作都锁定在整张表，开销少，加锁块，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低
2. 行级锁:每次操作锁定一行数据，开销大，加锁慢，会出现死锁，锁定粒度小，发生锁冲突的概率最低，并发度最高，使用行级锁定的主要是InnoDB存储引擎。
3. 页面锁：开销和加锁时间介于两者之间，会出现死锁，并发度一般
4. 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
5. 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性
```
乐观锁更适合解决冲突概率极小的情况，而悲观锁则适合解决并发竞争激烈的情况，尽量使用行锁,缩小加锁粒度，以提高并发处理能力，即使加行锁的时间比表锁要长
```

##四、innodb的事务与日志实现方式
###1. 日志种类
  - 错误日志：记录出错信息，也记录一些警告或是正确的信息
  - 查询日志：记录所有对数据请求信息，不论是否得到正确执行
  - 慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录进去
  - 二进制日志：记录对数据库执行更改的所有操作
  
###2. 事务是如何通过日志实现的
```
事务日志是通过redo和innodb的存储引擎日志缓冲来实现的，当开始一个事务的时候，会记录该事务的lsn号。
当事务执行时，会往innodb存储引擎日志缓存里面插入事务日志，当事务提交时，必须将存储引擎的日志缓存写入磁盘，也就是写数据前，要先写日志
```

###3. 日志格式
- Row Level
```
Binary Log会记录成每一行数据被修改的形式，然后在Slave端再对相同的数据进行修改。
如果修改了表的结构，那么binlog日志记录的是重新创建表，在插入字段、update等操作语句，而不是的alter的动作。

优点：在Row Level模式下，Binnary Log可以不记录执行的Query语句的上下文相关信息，只要记录哪一行修改了，修改成什么样子。
Row Level会详细的记录下每一行数据的修改细节，而且不会出现某个特定情况下的存储过程，或Function，以及Trigger的调用和触发无法被正确复制问题。
 
缺点：产生大量的日志内容。
```

- Statment Level
```
每一条会修改的SQL语句都会记录到Master的Binnary中。Slave端在复制的时候，SQL线程会解析成和原来Master端执行过相同的SQL语句，并再次执行。

优点：首先，解决了Row Level下的缺点，不须要记录每一行的数据变化，减少了Binnary Log日志量，节约了IO成本，提高了性能。

缺点：由于它是记录的执行语句，为了让这些语句在Slave端也能正确执行。那么它还必须记录每条语句在执行时的一些相关信息，
即上下文信息，以保证所有语句在Slave端被执行的时候能够得到和在Master端执行时相同的结果。另外，由于MySQL发展比较快，很多新功能不断加入，
使得MySQL复制遇到了不小的挑战，复制时设计的内容岳父在，越容易出bug。在Statement Level下，目前已发现不少的情况下会造成MySQL的复制问题。
主要是在修改数据使用了某些特定的函数货功能后，出现，
比如：Sleep()函数在有些版本中就不能正确的复制，在存储过程中使用了last_insert_id()函数，可能会使Slave和Master的到不一致的ID，等等。

```
- Mixed Level
```
在Mixed模式下，MySQL会根据执行的每一条具体的SQL语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。
除了MySQL认为通过Statement方式可能造成复制过程中Master和Slave之间产生不一致数据。(如特殊Procedure和Funtion的使用，
UUID()函数的使用等特殊情况)时，它会选择ROW的模式来记录变更之外，都会使用Statement方式。
```

#索引
索引是对数据库表中一个或多个列的值进行排序的结构，建立索引有助于快速获取信息。
```
mysql有4种不同的索引：
    主键索引（PRIMARY）
    唯一索引（UNIQUE）
    普通索引（INDEX）
    全文索引（FULLTEXT）

引并非是越多越好，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时要花费较多的时间维护索引
```

#优化

##一、mysql参数优化

- MySQL的配置参数都在my.conf或者my.ini文件的[mysqld]组中 
```
key_buffer_size:表示索引缓冲区的大小 
table_cache:表示同时打开的表的个数 
query_cache_size:表示查询缓冲区的大小 
sort_buffer_size 表示排序缓存区的大小 
read_buffer_size:表示每个线程连续扫描时为扫描每个表分配的缓冲区的大小 
read_rnd_buffer_size:表示为每个线程保留的缓冲区的大小 
innodb_buffer_pool_size:表示InnoDB类型的表和索引的最大缓存 
max_connections:表示数据库的最大连接数 
innodb_flush_log_at_trx_commit：表示何时将缓冲区的数据写入日志文件 
back_log:表示在mysql暂时停止回答新请求之前的短时间内，多少个请求可以放在堆栈中。 
interactive_timeout:表示服务器在关闭连接前等待行动的秒数。 
sort_buffer_size: 表示每个需要进行排序的线程分配的缓冲区的大小。 
thread_cache_size 表示可以复用的线程的数量 
wait_timeout 表示服务器在关闭一个连接时等待行动的秒数。默认数值时28800
```


#备份

##MySQL的复制原理以及流程
```
1）在Slave 服务器上执行sart slave命令开启主从复制开关，开始进行主从复制。

2）此时，Slave服务器的IO线程会通过在master上已经授权的复制用户权限请求连接master服务器，
    并请求从执行binlog日志文件的指定位置（日志文件名和位置就是在配置主从复制服务时执行change master命令指定的）之后开始发送binlog日志内容
    
3）Master服务器接收到来自Slave服务器的IO线程的请求后，二进制转储IO线程会根据Slave服务器的IO线程请求的信息分批读取指定binlog日志文件指定位置之后的binlog日志信息，
    然后返回给Slave端的IO线程。返回的信息中除了binlog日志内容外，还有在master服务器端记录的新的binlog文件名称，以及在新的binlog中的下一个指定更新位置。
    
4）当Slave服务器的IO线程获取到Master服务器上IO线程发送的日志内容、日志文件及位置点后，
    会将binlog日志内容依次写到Slave端自身的Relay Log（即中继日志）文件（MySQL-relay-bin.xxx）的最末端，并将新的binlog文件名和位置记录到master-info文件中，
    以便下一次读取master端新binlog日志时能告诉Master服务器从新binlog日志的指定文件及位置开始读取新的binlog日志内容
    
5）Slave服务器端的SQL线程会实时检测本地Relay Log 中IO线程新增的日志内容，然后及时把Relay LOG 文件中的内容解析成sql语句，
    并在自身Slave服务器上按解析SQL语句的位置顺序执行应用这样sql语句，并在relay-log.info中记录当前应用中继日志的文件名和位置点
```
